<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>NodeJS之Koa2</title>
      <link href="/archives/e2bc66af.html"/>
      <url>/archives/e2bc66af.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NodeJS之Express</title>
      <link href="/archives/d76f5c22.html"/>
      <url>/archives/d76f5c22.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NodeJS基础</title>
      <link href="/archives/942ad132.html"/>
      <url>/archives/942ad132.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文其实参考了很多的文章资料，在这里就不一一列出了，如果你在读这篇文章的时候，不巧看到了和自己写过的文章有类似或雷同的语句，请不要怀疑，就是我借鉴你的。此外，如果有和这篇文章雷同的，不胜荣幸！如果有什么问题，可以加我微信。</p></blockquote><h2 id="一、Node-js简介"><a href="#一、Node-js简介" class="headerlink" title="一、Node.js简介"></a>一、Node.js简介</h2><h3 id="Node-js诞生史"><a href="#Node-js诞生史" class="headerlink" title="Node.js诞生史"></a>Node.js诞生史</h3><p>  Node.js之父：<strong>Ryan Dahl</strong>（瑞安 <strong>·</strong> 达尔）</p><ul><li>并非计算机科班出生，2004年在纽约罗彻斯特大学数学系攻读数学博士。</li><li>2006年退学之后，偶然的机会走上了编程之路，在接项目的过程中遇到了主流服务器的瓶颈问题。</li><li>2008年Google公司的<strong>V8引擎</strong>横空出世，JavaScript语言的性能得到了质的提升，与它的想法碰撞出巨大的火花（他认为一个高性能的服务器应该满足 <strong>“事件驱动，非阻塞的I&#x2F;O”</strong>，而JavaScript又刚好满足）。</li><li>2009年2月，他提交了项目的第一行代码，并命名为Node。</li><li>2009年5月，正式向外宣布这个项目。</li><li>2009年底，在柏林举办的JSConf EU会议上正式发表关于Nodejs的演讲，此后Nodejs逐渐流行于世。</li><li>Ryan Dahl于2010年正式加入IBM旗下的Joyent公司，全职负责Nodejs的开发，也表示着Nodejs由个人项目成为了一个公司旗下的项目。</li></ul><h3 id="什么是Node-js？"><a href="#什么是Node-js？" class="headerlink" title="什么是Node.js？"></a>什么是Node.js？</h3><p> Nodejs是一个基于<strong>Chrome V8引擎</strong>的<strong>JavaScript运行环境</strong>。简单的来说它就是运行在服务端JavaScript，辅助大家来用JavaScript来开发高性能的服务器代码。通过下图来简要说明以下Nodejs的运行机制。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba492df4502f4a8a88db07a9d19f7bff~tplv-k3u1fbpfcp-watermark.image" alt="src=http___img.it610.com_image_info10_abe2c785590a41a69d86d4ead6ebbed0.png&amp;refer=http___img.it610.jpg"></p><h3 id="3、Node-js的特点"><a href="#3、Node-js的特点" class="headerlink" title="3、Node.js的特点"></a>3、Node.js的特点</h3><p>（1）、它是一个JavaScript的运行环境。<br/><br>（2）、以Chrom的V8引擎作为依赖<br/><br>（3）、事件驱动<br/><br>（4）、非阻塞的I&#x2F;O<br/><br>（5）、轻量的、可伸缩的<br/><br>（6）、单进程，单线程<br/></p><h3 id="4、我们为什么要学Node-js"><a href="#4、我们为什么要学Node-js" class="headerlink" title="4、我们为什么要学Node.js"></a>4、我们为什么要学Node.js</h3><p>&amp;emsp;近些年来，随着全栈工程师概念的兴起，本质上就是内卷</p><h3 id="5、安装Node-js"><a href="#5、安装Node-js" class="headerlink" title="5、安装Node.js"></a>5、安装Node.js</h3><h2 id="二、包管理器"><a href="#二、包管理器" class="headerlink" title="二、包管理器"></a>二、包管理器</h2><p>&amp;emsp;既然说到了npm包管理器：那么什么是包管理器呢？又有哪些包管理器呢？ <br/><br>&amp;emsp;包管理器（package manangerd）就是一种工具，它是帮我们管理包的（也就是应用程序），它允许我们在操作系统上安装、删除、升级、配置和管理软件包 <br/><br><strong>1）、npm</strong> <br/><br>&amp;emsp; 在我们下载Node.js时，就已经默认下载了npm<br/><br><strong>2）、yarn</strong> <br/></p><ul><li>安装yarn<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i yarn -g</span><br></pre></td></tr></table></figure></li><li>检查yarn是否安装成功<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn -v</span><br></pre></td></tr></table></figure></li><li>配置环境变量<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//配置环境变量之前先执行一下命令，获取yarn的安装目录</span><br><span class="line">//然后将这两个路径添加到我们的环境变量中</span><br><span class="line">//添加环境变量(右键此电脑 -&gt; 属性 -&gt; 高级系统设置 -&gt; 环境变量 -&gt; 用户变量 -&gt; Path -&gt; 添加路径 -&gt; 保存)</span><br><span class="line">yarn global dir  </span><br><span class="line">yarn global bin</span><br></pre></td></tr></table></figure></li><li>yarn与npm的命令对比<br>小细节：当文件名有中文时，使用npm init -y 初始化项目时会报错，而使用yarn init -y 就不会报错，但是在安装第三库的时候会报错，解决方法，使用yarn安装第三方库时，打开package.json将names属性中的中文改为英文或者去除即可。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//初始化项目</span><br><span class="line">yarn init -y</span><br><span class="line">npm init -y</span><br><span class="line">//安装项目所有声明依赖</span><br><span class="line">yarn </span><br><span class="line">npm install</span><br><span class="line">//下载指定运行时项目包</span><br><span class="line">yarn add xxx@1.0.0</span><br><span class="line">npm install xxx@1.0.0 --save   //--save-dev开发时依赖，--save运行时依赖</span><br><span class="line">//</span><br></pre></td></tr></table></figure></li></ul><p><strong>3）、cnpm</strong> <br/></p><ul><li>安装cnpm<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm -registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></li><li>检查是否安装成功<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm -v</span><br></pre></td></tr></table></figure>这里我个人比较推荐大家装一个yarn,</li></ul><h2 id="三、模块化"><a href="#三、模块化" class="headerlink" title="三、模块化"></a>三、模块化</h2><p>&amp;emsp;在学习Node.js之前，我们得先了解模块化这一概念，</p><h3 id="1、AMD"><a href="#1、AMD" class="headerlink" title="1、AMD"></a>1、AMD</h3><h3 id="2、CommonJS"><a href="#2、CommonJS" class="headerlink" title="2、CommonJS"></a>2、CommonJS</h3><h3 id="3、CMD"><a href="#3、CMD" class="headerlink" title="3、CMD"></a>3、CMD</h3><h3 id="4、ES6模块化"><a href="#4、ES6模块化" class="headerlink" title="4、ES6模块化"></a>4、ES6模块化</h3><h2 id="四、初识Node-js"><a href="#四、初识Node-js" class="headerlink" title="四、初识Node.js"></a>四、初识Node.js</h2><p>&amp;emsp;通过前面的介绍，相信同学们一定对Node.js有了初步了解,在真正学习Node.js之前，我希望同学们可以了解一些概念性的东西，下面的内容可能会有点枯燥，因为基本上是一些纯理论的东西。但是，我相信在你耐心看完之后，会对浏览器工作原理有一定的理解。</p><h3 id="1、浏览器引擎"><a href="#1、浏览器引擎" class="headerlink" title="1、浏览器引擎"></a>1、浏览器引擎</h3><p>&amp;emsp;在此之前，我们先了解一下浏览器是干什么的，浏览器的主要功能就是帮助我们渲染页面执行我们编写的JavaScript代码，<code>浏览器内核</code>这一概念，什么是浏览器内核？事实上，我们常说的浏览器内核就是浏览器的排版引擎排版引擎，也称为<code>浏览器引擎</code>、<code>页面渲染引擎</code>或者<code>样板引擎</code>。其实，不同的浏览器由不同的内核组成，那么常见的浏览器内核有哪些？<br/></p><ul><li><strong>Gecko</strong>：早期被Netscape和Mozilla Firefox 使用。 <br/></li><li><strong>Trident</strong>：微软开发，被IE4-IE11使用，但是edge现在使用的是Blink。 <br/></li><li><strong>Webkit</strong>：苹果基于KHTML开发，开源的，用于Safari、Google Chrome之前也在使用。 <br/></li><li><strong>Blink</strong>：是Webkit的一个分支，Google开发，目前应用于Google Chrome、Edge、Opera等。 <br/><h3 id="2、浏览器渲染引擎的工作过程"><a href="#2、浏览器渲染引擎的工作过程" class="headerlink" title="2、浏览器渲染引擎的工作过程"></a>2、浏览器渲染引擎的工作过程</h3>&amp;emsp;在学习浏览器渲染引擎的工作过程之前。我们先思考一个问题，当HTML解析过程中，遇到了JavaScript标签怎么办？ <br/><br>&amp;emsp;会<code>停止执行HTML，转而去执行JavaScript代码</code>，我想这时候就有人问了，那为什不异步执行JavaScript代码呢？这样效率岂不是更高？这是因为<code>JavaScript代码可以操作我们DOM</code>，所以浏览器希望将HTML解析的DOM和JavaScript操作之后的DOM放到一起来生成最终的DOM树，而不是去频繁的去生成新的DOM树。我们通过下面这幅图来解释一下浏览器的渲染过程,以webkit为例。</li></ul><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e63a24d0d4b41c683f70bc032d17376~tplv-k3u1fbpfcp-watermark.image" alt="image.png"> <br/><br>不同的浏览器引擎之间，其渲染过程只有略微的差异，基本都是相同的。大致可以分为以下几步。<br/><br>&amp;emsp;<strong>第一步</strong>：浏览器通过HTML分析器将HTML解析成一个<code>DOM树</code>，DOM树的构建是一个<code>深度遍历</code>的过程，即当前节点的所有子节点都构建好了之后才回去构建当前节点的下一个兄弟节点。<br/><br><code>注意：</code>在构建DOM树的时候，如果遇script标签，则会调用<code>JavaScript引擎</code>进行解析，如果遇到CSS、图片、音视频则会调用<code>资源加载器</code>进行下载。这也解释了为什么JavaScript文件尽量放在底部（script会阻塞DOM树的构建，也防止没有DOM树，JavaScript无法操作DOM树）。<br/><br>&amp;emsp;<strong>第二步</strong>：浏览器通过CSS分析器将CSS文件和标签的内联样式解析成<code>CSS Rule Tree</code>。<br/><br>&amp;emsp;<strong>第三步</strong>：通过<code>DOM树</code>和<code>CSSOM树</code>来构建<code>Render Tree</code>（这个过程称为Attachment）。 <br/><br><code>注意</code>：<code>Render Tree</code>并不完全等于<code>DOM树</code>，某些节点设置为<code>display:none</code>就不会在渲染树中显示。<br/><br>&amp;emsp;<strong>第四步</strong>：有了Render Tree浏览器就知道网页中有哪些节点、各节点的从属关系以及CSS的定义，浏览器开始<code>布局</code>，为每个出现在Render Tree上的节点在屏幕上确定一个精确的坐标。<br/><br>&amp;emsp;<strong>第五步</strong>：遍历Render Tree，<code>绘制</code>每一个节点。<br/><br><strong>总结</strong>：以上这个过程是<code>逐步完成</code>的，不会等到HTML全部解析完成再去构建和布局Render树，因为这样会导致页面的空白，影响用户的体验。事实上，它是<code>解析完一部分内容就显示一部分内容</code>。 <br/><br>&amp;emsp;如果想要详细的了解浏览器页面渲染机制，推荐一位掘金前端大神<a href="https://juejin.cn/user/4283353031252967">浪里行舟</a>写的一篇关于<a href="https://juejin.cn/post/6844903815758479374#heading-1">浏览器页面渲染机制</a>的文章。</p><h3 id="3、JavaScript引擎"><a href="#3、JavaScript引擎" class="headerlink" title="3、JavaScript引擎"></a>3、JavaScript引擎</h3><p>&amp;emsp;上面提到在构建DOM树的时候，如果遇到script标签，则会调用JavaScript代码进行解析。那么我们的在来简单的聊一聊JavaScript引擎。还是老样子，思考一下我们为什么需要JavaScript引擎？<br/><br>&amp;emsp;思考时间到，跟着我来看看吧！我们编写的JavaScript代码，无论你是交给浏览器执行或者Node执行。<code>最后都是需要被CPU执行</code>的。但是，我们知道<code>CPU它只认识机器语言</code>（也就是0、1），不认识JavaScript。所以我们就需要一个东西可以将我们的<code>JavaScript代码转化为CPU认识的指令集</code>，那么JavaScript引擎就应运而生了。<br/><br><strong>（1）、JavaScript引擎有哪些？</strong> <br/></p><ul><li><strong>SpiderMonkey</strong>：第一款JavaScript引擎，由<a href="https://baike.baidu.com/item/%E5%B8%83%E5%85%B0%E7%99%BB%C2%B7%E8%89%BE%E5%A5%87/58101949?fromtitle=Brendan%20Eich&fromid=561441&fr=aladdin">Brendan Eich</a>开发（也就是JavaScript作者）</li><li><strong>Chakra</strong>：微软开发，用于使用IT浏览器</li><li><strong>JavaScriptCore</strong>：WebKit中的JavaScript引擎，Apple公司开发</li><li><strong>V8</strong>：Google开发的强大JavaScript引擎，也帮助Chrome脱颖而出。</li></ul><p><strong>（2）、JavaScript引擎和浏览器内核</strong> <br/><br>&amp;emsp;JavaScript引擎与浏览器引擎有什么区别呢？有很多小伙伴都会把它们搞混。下面以WebKit内核为例，分析以下它们之间的关系。<br/><br>&amp;emsp;WebKit事实上是由以下两部分组成：<br/></p><ul><li><strong>WebCore</strong>：负责HTML解析、布局、渲染等等相关的工作。</li><li><strong>JavaScriptCore</strong>：解析，执行JavaScript代码 。</li></ul><p><strong>（3）、V8引擎</strong> <br/><br>&amp;emsp;V8引擎是用C++编写的Google开源的高性能JavaScript和WebAssembly引擎，它用于Chrome和Node.js等。V8可以独立运行，也可以嵌入到任何的C++应用程序中。<br/><br>&amp;emsp;<strong>1）、V8执行JavaScript流程</strong></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cff936f4e85d4f5282737d087033c4dd~tplv-k3u1fbpfcp-watermark.image" alt="v8编译原理"><br>&amp;emsp;流程图见上图,下面我们来具体的分析一下相关的流程。<br/><br><strong>步骤一</strong>：<code>JavaScript转AST（抽象语法树）</code>，V8引擎在拿到JavaScript代码后，通过Parse（解析器）将代码转化成抽象语法树，生成AST过程中它会进行两个阶段即<code>词法分析</code>、<code>语法分析</code>。<br/></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下面的代为例来展示 “词法分析” 、 “语法分析”</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a,b</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&amp;emsp;<strong>词法分析</strong>：将代码拆分为Token,<code>Token是能拆分的最小单位</code>，type表示属性&#x2F;类型，value表示对应值,如下图所示。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例代码词法分析结果</span></span><br><span class="line">[</span><br><span class="line">    &#123;<span class="string">&quot;type&quot;</span> : <span class="string">&quot;Keyword&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="string">&quot;const&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;type&quot;</span> : <span class="string">&quot;Identifier&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="string">&quot;a&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;type&quot;</span> : <span class="string">&quot;Punctuator&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="string">&quot;=&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;type&quot;</span> : <span class="string">&quot;Numeric&quot;</span>, <span class="string">&quot;value&quot;</span>: <span class="string">&quot;2&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;type&quot;</span> : <span class="string">&quot;Punctuator&quot;</span>, <span class="string">&quot;value&quot;</span>: <span class="string">&quot;;&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;type&quot;</span> : <span class="string">&quot;Keyword&quot;</span>, <span class="string">&quot;value&quot;</span>: <span class="string">&quot;const&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;type&quot;</span> : <span class="string">&quot;Identifier&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="string">&quot;b&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;type&quot;</span> : <span class="string">&quot;Punctuator&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="string">&quot;=&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;type&quot;</span> : <span class="string">&quot;Numeric&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="string">&quot;3&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;type&quot;</span> : <span class="string">&quot;Punctuator&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="string">&quot;;&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;type&quot;</span> : <span class="string">&quot;Keyword&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="string">&quot;function&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;type&quot;</span> : <span class="string">&quot;Identifier&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="string">&quot;sum&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;type&quot;</span> : <span class="string">&quot;Punctuator&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="string">&quot;(&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;type&quot;</span> : <span class="string">&quot;Identifier&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="string">&quot;a&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;type&quot;</span> : <span class="string">&quot;Punctuator&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="string">&quot;,&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;type&quot;</span> : <span class="string">&quot;Identifier&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="string">&quot;b&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;type&quot;</span> : <span class="string">&quot;Punctuator&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="string">&quot;)&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;type&quot;</span> : <span class="string">&quot;Punctuator&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="string">&quot;(&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;type&quot;</span> : <span class="string">&quot;Punctuator&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="string">&quot;&#123;&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;type&quot;</span> : <span class="string">&quot;Identifier&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="string">&quot;console&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;type&quot;</span> : <span class="string">&quot;Punctuator&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="string">&quot;)&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;type&quot;</span> : <span class="string">&quot;Identifier&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="string">&quot;log&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;type&quot;</span> : <span class="string">&quot;Punctuator&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="string">&quot;(&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;type&quot;</span> : <span class="string">&quot;Identifier&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="string">&quot;a&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;type&quot;</span> : <span class="string">&quot;Punctuator&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="string">&quot;+&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;type&quot;</span> : <span class="string">&quot;Identifier&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="string">&quot;b&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;type&quot;</span> : <span class="string">&quot;Punctuator&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="string">&quot;)&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;type&quot;</span> : <span class="string">&quot;Punctuator&quot;</span>, <span class="string">&quot;value&quot;</span> : <span class="string">&quot;;&quot;</span>&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>&amp;emsp;<strong>语法分析</strong>：在进行词法分析转为Token之后，解析器继续根据生成的Token生成对应的AST，AST其实我们并不陌生,比如Vue、Babel的编译（Babel编译过程：）等、解析器解析之后的 AST 结构如下图所示：<br/><br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4551489e35fa47a0950b820e6d9ece7b~tplv-k3u1fbpfcp-watermark.image" alt="image.png">&amp;emsp;<br><strong>步骤二</strong>：<code>AST转字节码</code>,在解析器（Parse）将JS代码转化为AST后，<code>解释器（Ignition）根据AST来生成字节码</code>。而前文提到的<code>CPU只能识别机器码，不能识别字节码</code>。那么我们为什么不直接将我们的AST转化成机器码呢？何必要转换成字节码呢？原来，引入字节码其实是为了解决<a href="https://v8.dev/blog/preparser">V8惰性编译</a>这个问题的。问题又来了什么是<code>惰性编译</code>，从作用域角度思考，V8启动的时候<code>只编译和缓存全局作用域的，而函数作用域的代码会在调用的时候去编译</code>，且函数内部编译的代码一样不会被缓存下来。引入惰性编译后，V8的编译速度确实得到了提升，但是我们说引入字节码是为了解决惰性编译的问题的，那么它又有什么问题呢？由于在ES6、VUE等还未普及之前开发大多用的都是jQuery，而开发者为了自己封装的方法不污染其他人使用的变量，一般都会封装成一个函数。这样问题就来了，惰性编译不会保存函数编译后的机器码，那么如果一个插件很大，而又在当你使用的时候才去编译，毫无疑问编译时间就会变得很慢！那么V8惰性编译存在的意义又何在呢？此时，Chrome的V8团队就引入的字节码，那么什么是字节码？其实字节码就是机器码的抽象，但是它要比机器码内存占用小很多。解释器（Ignition）在将AST转化为<br>字节码之后会在执行的时候将字节码转化为机器码，这个过程肯定会比直接执行机器码慢一点。而JS源码通过解析器转化为AST，AST又通过解释器转化为字节码这一过程又比JS源码直接转化为字节码快一点。从整个流程来看，其实速度基本差不多，但是字节码又减少了大量的内存的占用。所以就引入了字节码这一中间过渡。<br/></p><p><strong>步骤三</strong>：<code>字节码转化机器码</code>,在我们代码中通常有都会又一部分会被经常调用，如果这部分代码每次都需要经过解释器转化为二进制代码去执行。那么无疑性能上会有很大的浪费。所以在V8中设置了专门的监控模块，来监视同一代码是否会被多次调用，如果被多次调用那么它将会被标记成<code>热代码</code>,如果被标记为热代码后，V8会通过<code>TurboFan（优化编辑器）</code>将热代码的字节码转化为二进制机器码缓存下来。这样我们在调用热代码时就不需要再经过字节码转热代码这一过程了，提升了部分效率。这个过程就是<code>优化（optimizing）</code>。与之对应的就是<code>去优化（deoptimizing）</code>,我们都知道JavaScript是一门非常灵活的语言，如果热代码再某次执行时属性发生的修改，那么热代码编译成的机器码就无法执行了，此时就需要使用TurboFan的反优化了，过程：首先将热代码回退到字节码这一步，这时解释器会重新解释执行被修改的代码，如果该代码又被多次执行就重复上面的过程。举个栗子吧！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a,b</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a + b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//比如上面这块代码被多次调用，并且传入的值都为Number类型。此时这段代码就会变成热代码（优化）</span></span><br><span class="line"><span class="title function_">sum</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">/*如果再某一时刻我们突然传入String类型的值后，我们知道String类型的加法，做的是字符串的拼接</span></span><br><span class="line"><span class="comment">*与Number类型的截然不同，之前优化的机器码不能正确的处理运算，就会逆向的转化为字节码（去优化）。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title function_">sum</span>(<span class="string">&quot;123&quot;</span>,<span class="string">&quot;456&quot;</span>);</span><br><span class="line"><span class="comment">//注意:建议大家不要随意的改变默写代码的属性，这样会影响V8的性能，好在现在推出了Typescript,可以帮助我们更加的规范代码。</span></span><br></pre></td></tr></table></figure><p>&amp;emsp;<strong>2）、V8引擎内置模块</strong><br/><br>&amp;emsp;经过上面的介绍，我相信同学们一定对V8执行JavaScript源码的流程有一定的了解了，下面是关于上面流程所用的V8三大模块的总结概述。</p><ul><li><strong>Parse</strong><br>Parse模块会将JavaScript代码转换成AST（抽象语法树），这是因为解释器并不直接认识JavaScript代码。<br/><br>&amp;emsp;如果函数没有被调用，那么是不会被转换成AST的；<br/><br>&amp;emsp;Parse官方文档：<a href="https://v8.dev/blog/scanner">https://v8.dev/blog/scanner</a> <br/></li><li><strong>Ignition</strong><br>Ignition是一个解释器，会将AST转化为ByteCode（字节码）<br/><br>&amp;emsp;同时会收集TurboFan优化所需要的信息（比如：函数参数的类型，有了类型才能进行真实的运算）<br/><br>&amp;emsp;如果函数只调用一次，Ignition会执行解释执行ByteCode；<br/><br>&amp;emsp;Ignition的V8官方文档：<a href="https://v8.dev/blog/ignition-interpreter">https://v8.dev/blog/ignition-interpreter</a></li><li><strong>TurboFan</strong>: <br/><br>TurboFan是一个编译器，可以将字节码编译成为CPU可以直接执行的机器码。<br/><br>&amp;emsp;如果一个函数被多次调用，那么就会被标记为热点函数，那么就会经过TurboFan转化为机器码，提高代码的执行性能；<br/><br>&amp;emsp;但是，机器码实际上也会被还原成ByteCode，这是因为如果在后续执行函数的过程中，类型发生了变化（如sum函数原来执行的是number类型，后来执行变成了string类型），之前优化的机器码并不能正确的处理运算，就会逆向的转化为字节码；<br/><br>&amp;emsp;TurboFanr的官方文档：<a href="https://v8.dev/blog/turbofan-jit">https://v8.dev/blog/turbofan-jit</a> <br/></li></ul><p><strong>（4）、v8垃圾回收机制</strong> <br/><br>&amp;emsp;既然说到了V8引擎，那么就顺便来说一下V8的垃圾回收机制</p><h2 id="四、Node的事件循环"><a href="#四、Node的事件循环" class="headerlink" title="四、Node的事件循环"></a>四、Node的事件循环</h2><p>&amp;emsp;说到Node的事件循环，就不得不拿出这张图（经典）。<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/728c71781bf44bd798f159159148f720~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>1、事件循环：<br>    可以理解为我们编写的JavaScript代码和浏览器或者Node之间的桥梁.<br>2、浏览器之间的事件循环是一个我们编写的JavaScript代码和浏览器API调用（setTimeout&#x2F;AJAX&#x2F;监听事件等）<br>的一个桥梁，桥梁之间他们通过回调函数进行沟通。<br>3、Node的事件循环是一个我们编写的JavaScript代码和系统调用（fill system、network等）之间的一个桥梁，<br>桥梁之间他们通过回调函数进行沟通。</p><p>一、进程和线程<br>1、线程和进程是操作系统中的两个概念<br>    进程：计算机已经运行的程序。是操作系统管理程序的一种方式<br>    线程：操作系统能够运行运算调度的最小单位，通常情况下它被包含在进程中<br>看起来很抽象，解释一下：<br>    进程：我们可以认为，启动一个应用程序，就会默认启动一个进程（也可能是多个进程）<br>    线程：每一个进程中，都会启动一个线程用来执行程序中的代码，这个线程被称之为主线程<br>    所以我们也可以说进程是线程的容器</p><p>2、多进程多线程<br>操作系统是如何做到同时让多个进程同时工作的呢？<br>    因为CPU的运算速度非常的快，它可以快速的在多个进程之间迅速的切换<br>    当我们的进程中的线程获取到时间片，就可以快速的执行我们编写的代码<br>    用户是感觉不到这种快速切换的</p><p>3、浏览器和JavaScript<br>我们经常可以听到JavaScript是单线程的，这就意味着JavaScript代码，在同一时刻只能做一件事；<br>如果这件事是非常耗时的，就意味着当前线程就会被阻塞</p><p>4、事件循环其实是很简单的东西<br>栈和队列<br>每一个回调函数就是一个任务，会被加入到宏任务队列（macrotask queue）<br>    AJAX、setTimeout、setInterval、DOM监听、UI Rendering等<br>例如promise产生的回调，就会加入到微任务队列(microtask queue)<br>    Promise的Then回调、Mutation Observer API 、 queueMicrotask()</p><p>5、宏任务和微任务（重点）<br>浏览器会优先执行微任务队列，<br>当宏任务队列和微任务队列中都有要执行的操作时，会优先将微任务队列中的所有的操作<br>全部执行完毕后才会去执行宏任务<br>注意：当我们正在执行宏任务队列时，微任务队列中此时加入了新的操作，那么此时将会暂停宏任务队列<br>转而去执行微任务队列，直到微任务队列执行完毕为空时，才会继续执行宏任务队列。</p><p>6、Node的事件循环<br>Node中是由libuv实现的<br>libuv主要维护了一个Eventloop和work threads(线程池)；<br>EventLoop负责调用系统的一些其他操作，文件的IO、NetWork 、child-process等<br>想看node的源码在deps中看v8、libuv、npm等源码</p><p>7、阻塞IO和非阻塞IO<br>事实上对文件的操作，是一个操作系统的系统调用（IO系统）<br>两种调用方式：阻塞式调用和非阻塞式调用<br>阻塞式调用：调用结果返回前，当线程处于阻塞态（阻塞态CPU是不会分配时间片的）调用线程只有在得到调用结果之后<br>才会继续执行。<br>非阻塞式调用：调用执行后，当前线程不会停止执行，只需要过一段时间来检查一下有没有结果返回即可。</p><p>我们开发中的很多耗时操作，都可以基于这样的非阻塞式调用<br>比如网络请求本身使用Socket通信，而Socket本身提供了select模型，可以进行非阻塞方式的调用<br>比如文件读写的IO操作，我们可以使用操作系统提供的基于事件的回调机制</p><p>非阻塞IO的问题<br>我们没有获取到需要获取的读取结果<br>那么意味着为了知道是否读取到了完整的数据，我们需要去频繁的确定读取到的数据是否完整<br>这个过程我们称为轮询操作<br>轮询谁来完成呢？<br>如果由主线程频繁的去进行轮询操作，那么必然会大大降低性能<br>libuv为我们提供了一个线程池</p><p>8、阻塞和非阻塞，同步和异步区别<br>阻塞和非阻塞是对于被调用者来说的；在这里就是系统调用，操作系统为我们提供了阻塞调用和非阻塞调用<br>同步和异步是对于调用者来说的<br>在我们这里就是自己的程序<br>如果我们在发起调用后，不会进行其他任何的操作，只是等待结果，这个过程称为同步调用<br>如果我们发起调用结果，并不会等待结果，继续完成其他的工作，等到有回调才去执行，这个过程就是异步调用</p><p>9、事件循环<br>无论是文件的IO操作、数据库、网络IO、定时器、子进程，在完成对应的操作后，都会将对应的结果和回调函数放到<br>事件循环队列中去<br>事件循环会不断的从任务队列中取出对应的事件（回调函数）来执行<br>但是一次完成的事件循环Tick分为很多个阶段<br>定时器(Timers)：本阶段执行已经被setTimeout()和setInterval()的调度回调函数<br>待时回调(Pending Callback)：对某些系统操作（如TCP错误类型）执行回调，比如TCP连接<br>idle、prepare：仅限系统内部使用。<br>轮询(Poll)：检索新的I&#x2F;O事件；执行与I&#x2F;O相关的回调<br>检测：setImmediate():回调函数在这里执行。<br>关闭的回调函数：一些关闭的回调函数，如：socket.on…</p><p>10、Node中的微任务和宏任务</p><p>宏任务和微任务<br>面试题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;set1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>)&#123;</span><br><span class="line">        <span class="title function_">resolve</span>();</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>)&#123;</span><br><span class="line">            <span class="title function_">resolve</span>();</span><br><span class="line">        &#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;then4&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;then2&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;pr1&quot;</span>);</span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;then1&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;set2&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">queueMicrotask</span>(<span class="function">() =&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;queueMicrotask1&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>)&#123;</span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;then3&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：要画图分析过程</span></span><br><span class="line"><span class="comment">// pr1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// then1</span></span><br><span class="line"><span class="comment">// queueMicrotask1</span></span><br><span class="line"><span class="comment">// then3</span></span><br><span class="line"><span class="comment">// set1</span></span><br><span class="line"><span class="comment">// then2</span></span><br><span class="line"><span class="comment">// then4</span></span><br><span class="line"><span class="comment">// set2</span></span><br></pre></td></tr></table></figure><p>面试题二</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 start&quot;</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">async2</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setTimeout&quot;</span>);</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">async1</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span> (<span class="keyword">function</span>(<span class="params">resolve</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise2&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script end&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//画图分析</span></span><br><span class="line"><span class="comment">// script start</span></span><br><span class="line"><span class="comment">// async1 start</span></span><br><span class="line"><span class="comment">// async2</span></span><br><span class="line"><span class="comment">// promise1</span></span><br><span class="line"><span class="comment">// script end</span></span><br><span class="line"><span class="comment">// async1 end</span></span><br><span class="line"><span class="comment">// promise2</span></span><br><span class="line"><span class="comment">// setTimeout</span></span><br></pre></td></tr></table></figure><p>Node队列面试题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 start&quot;</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">async2</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setTimeout0&quot;</span>);</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setTimeout2&quot;</span>);</span><br><span class="line">&#125;,<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">setImmediate</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setImmediate&quot;</span>));</span><br><span class="line"></span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;nextTick1&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="title function_">async1</span>();</span><br><span class="line"></span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;nextTick2&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise2&quot;</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise3&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script end&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//画图分析</span></span><br><span class="line"><span class="comment">// script start</span></span><br><span class="line"><span class="comment">// async1 start</span></span><br><span class="line"><span class="comment">// async2</span></span><br><span class="line"><span class="comment">// promise1</span></span><br><span class="line"><span class="comment">// promise2</span></span><br><span class="line"><span class="comment">// script end</span></span><br><span class="line"><span class="comment">// nextTick1</span></span><br><span class="line"><span class="comment">// nextTick2</span></span><br><span class="line"><span class="comment">// async1 end</span></span><br><span class="line"><span class="comment">// promise3</span></span><br><span class="line"><span class="comment">// setTimeout0</span></span><br><span class="line"><span class="comment">// setImmediate</span></span><br><span class="line"><span class="comment">// setTimeout2</span></span><br></pre></td></tr></table></figure><p>面试题二</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setTimeout&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">setImmediate</span>(<span class="function">() =&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setImmediate&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="四、Node-js常用模块"><a href="#四、Node-js常用模块" class="headerlink" title="四、Node.js常用模块"></a>四、Node.js常用模块</h2><h3 id="1、fs模块（文件模块）"><a href="#1、fs模块（文件模块）" class="headerlink" title="1、fs模块（文件模块）"></a>1、fs模块（文件模块）</h3><p>&amp;emsp;在Node.js中文件模块是一个非常重要的模块</p><h3 id="2、文件流"><a href="#2、文件流" class="headerlink" title="2、文件流"></a>2、文件流</h3><p><strong>（1）、什么是 “流”(stream)</strong> ？<br/><br>&amp;emsp;<strong>“流”</strong> 是一个比较抽象的概念，不好理解。但是我么可以将它实例化成“水流”，我们可以思考一下水流有什么样的特点，水流都是从一个点流向另一个点的且具有方向性，程序中的“流”也有类似的含义，当我们从文件中读取数据时，文件中的数据以二进制的形式源源不断的被读取到我们的程序中。这一串的字节就是流。至于是输入流还是输出流在是一个相对的概念，一般以程序作为参考，如果数据的流向是程序到设备，那么就是输出流，反之则是输入流。<br/><br><strong>思考:</strong> 我们上面已经学习了<strong>readFile()</strong> 和<strong>writeFile()</strong> 就已经可以对文件进行读写了,为什么还要学习流？<br/><br>&amp;emsp;1）、readFile()和writeFile()虽然可以读取文件内容和向文件中写入内容，但是都是<strong>一次性的全部读取或写入</strong>。<br/><br>&amp;emsp;2）、在某些情况下，我们<strong>需要控制一些细节</strong>，比如：<strong>从什么位置开始读，从什么位置结束，每次读取的多少个字节。读取到某个位置时暂停读取，到某个时刻时回复读取</strong>等。<br/><br><strong>（2）、Node.js的基本流</strong> <br/><br>&amp;emsp;<strong>1）、Readable</strong>：可读流&amp;nbsp;fs.creatReadStream<br/></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入文件模块</span></span><br><span class="line"><span class="keyword">const</span> fs  = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、传统方式读取文件（一次性）</span></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./语录1.txt&#x27;</span>,&#123;<span class="attr">encoding</span>:<span class="string">&quot;utf-8&quot;</span>&#125;,<span class="function">(<span class="params">err,data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);<span class="comment">// 大梦谁先觉，平生我自知！</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//2、使用流读取文件</span></span><br><span class="line"><span class="comment">//它是没有回调函数的，我们需要监听事件</span></span><br><span class="line"><span class="keyword">const</span> rs = fs.<span class="title function_">createReadStream</span>(<span class="string">&quot;./语录1.txt&quot;</span>,&#123;</span><br><span class="line">    <span class="attr">start</span>:<span class="number">3</span>,</span><br><span class="line">    <span class="attr">end</span>:<span class="number">9</span>,</span><br><span class="line">    <span class="attr">highWaterMark</span>:<span class="number">3</span>,</span><br><span class="line">&#125;);</span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&quot;data&quot;</span>,<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data); <span class="comment">//&lt;Buffer e6 a2 a6&gt; &lt;Buffer e8 b0 81&gt;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>&amp;emsp;<strong>2）、Writable</strong>：可写流 &amp;nbsp;fs.creatReadStream<br/><br>&amp;emsp;<strong>3）、Duplex</strong>：双工流&amp;nbsp;同时实现Readable和writable的流<br/><br>&amp;emsp;<strong>4）、transform</strong>：转换流&amp;nbsp;Duplex可以在读取和写入数据时修改或转换数据的流<br/><br>所有的stream都是EvevtEmitter的实例,我们可以看一下node的源码<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a05bc00cd7ec4906aae7edfbd5c1d85e~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h3 id="3、Buffer（缓冲区）"><a href="#3、Buffer（缓冲区）" class="headerlink" title="3、Buffer（缓冲区）"></a>3、Buffer（缓冲区）</h3><p><strong>（1）、Buffer的定义</strong> <br/><br>&amp;emsp;我们先来看官方对于Buffer的解释：JavaScript自身只有字符串类型，没有二进制类型。但是在处理像TCP流或文件流，就必须使用到二进制数据。因此，在Node.js中，定义了一个Buffer类，该类用来创建一个专门存放二进制数据的缓存区。对于没有计算机基础的同学，可能不太理解二进制数据、TCP流。这里稍微讲一下，<strong>二进制数据</strong>：在计算机中所有的文本、字符串、音乐、视频、图片等都是以二进制的形式存储的（也就是0、1的形式），在计算机中我们很少操作一位二进制数，一般我们会将八位（<strong>bit</strong>）二进制数作为一个单元（<strong>字节：byte</strong>）进行操作，字节也有一个转化的公式 <strong>1byte &#x3D; 8bit、1kb &#x3D; 1024byte、1M &#x3D; 1024kb</strong>等。至于TCP， 它是 <strong>基于字节流的传输层的通信协议</strong>，它在写入和读取时都需要说明字节的个数。如果想要深入了解TCP，大家可以去看看计算机网络相关的书籍，这些都是一些很基础的东西。<br/><br><strong>（2）、Buffer和字符集</strong> <br/><br>&amp;emsp;Buffer其实可以将它看作为一个数组，数组中的每一项就对应一个字节大小，那么向Buffer中存储数据的过程是怎样的呢？ <br/><br>&amp;emsp;下面以字符串在Buffer中的存储过程来解释原理：<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f348a9b53164d67b865c5895a19187c~tplv-k3u1fbpfcp-watermark.image" alt="image.png" title="buffer存储过程"><br>了解了Buffer存储的基本过程，那么我们看看具体代码该怎么写，talk is cheap,show me the code.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> message = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*注意：使用一下这种方式创建一个Buffer,Node会打印一下信息</span></span><br><span class="line"><span class="comment">*DeprecationWarning: Buffer() is deprecated due to security and usability issues.</span></span><br><span class="line"><span class="comment">*这是告诉我们用这种方式来创建Buffer已经过期了，这里只是一个例子，后面会使用其他方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> buffer = <span class="keyword">new</span> <span class="title class_">Buffer</span>(message);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*这里它是用十六进制来表示二进制数的，下面稍微说一下十六进制</span></span><br><span class="line"><span class="comment">* 每一位的取值范围都是0-15（0-f）</span></span><br><span class="line"><span class="comment">*最大值介于00-ff之间，以H为例：H ：72 (十)=&gt; 1001000（二:）  转化为十六进制;</span></span><br><span class="line"><span class="comment">* 0000 0100 0000 1000（十六：0x） =&gt; 48 （也可表示为0x48）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buffer); <span class="comment">//&lt;Buffer 48 65 6c 6c 6f 20 57 6f 72 6c 64&gt;</span></span><br></pre></td></tr></table></figure><p>下面我们在来介绍一下比较常用的字符集（字符编码）<br/></p><ul><li><strong>ASCII</strong> <br/></li><li><strong>UTF-8</strong> <br/></li><li><strong>utf16le</strong> <br/></li></ul><p><strong>（3）、Buffer常用API</strong> <br/><br>&amp;emsp;Buffer为我们提供的API是相当的多,我不可能在这里全部多演示一遍，我只挑一些最常用的说一下，其他的同学们可以去查<a href="https://nodejs.org/dist/latest-v14.x/docs/api/buffer.html">Node.js官方文档</a>。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a94d203893724d49baeaee4ca886678c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br><strong>1）、buffer.from()</strong> <br/></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//转化英文</span></span><br><span class="line"><span class="keyword">const</span> message = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="comment">//创建Buffer的方式二，上面那个为方式一（不推荐使用）</span></span><br><span class="line"><span class="comment">//用这种方式来将一个字符串转化成Buffer,现在更加的常用</span></span><br><span class="line"><span class="keyword">const</span> buffer = <span class="keyword">new</span> <span class="title class_">Buffer</span>.<span class="title function_">from</span>(message);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buffer);<span class="comment">// &lt;Buffer 48 65 6c 6c 6f 20 57 6f 72 6c 64&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//转化中文</span></span><br><span class="line"><span class="keyword">const</span> msg = <span class="string">&quot;你好&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> buffer2 = <span class="keyword">new</span> <span class="title class_">Buffer</span>.<span class="title function_">from</span>(msg);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*注意：转化为中文的时候，会按照Unicode编码；</span></span><br><span class="line"><span class="comment">*正常情况下一个汉字（除了某些特别的生僻字）由三个字节来表示，如： e4 a0 e5 就表示“你” 。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buffer2); <span class="comment">//&lt;Buffer e4 bd a0 e5 a5 bd&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*注意：有一个细节，默认情况下的编码节码都为utf-8,用什么编码就需要用什么来解码。</span></span><br><span class="line"><span class="comment">*我们可以在Buffer.from(）传入一个encoding(编码方式)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> buffer3 = <span class="keyword">new</span> <span class="title class_">Buffer</span>.<span class="title function_">from</span>(msg,<span class="string">&quot;utf16le&quot;</span>);</span><br><span class="line"><span class="comment">//同样的字符串使用utf16b编码则会产生不同的结果</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buffer3); <span class="comment">// &lt;Buffer 60 4f 7d 59&gt;’</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*toString()可以将二进制数据转化为字符串形式输出</span></span><br><span class="line"><span class="comment">*如果采用utf16le编码而采用默认utf-8解码，那么将会产生不可预料的结果。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buffer3.<span class="title function_">toString</span>()); <span class="comment">// `O&#125;Y</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buffer.<span class="title function_">toString</span>(<span class="string">&quot;utf16le&quot;</span>)); <span class="comment">// 你好</span></span><br></pre></td></tr></table></figure><p><strong>2）、buffer.alloc()</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Buffer的方式三</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*Buffer.alloc(size[,fill[,encoding])</span></span><br><span class="line"><span class="comment">*在创建Buffer时传入大小，就会生成一个指定大小的Buffer</span></span><br><span class="line"><span class="comment">*此时Buffer中的内容是为空的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> buffer4 = <span class="keyword">new</span> <span class="title class_">Buffer</span>.<span class="title function_">alloc</span>(<span class="number">8</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buffer4); <span class="comment">// &lt;Buffer 00 00 00 00 00 00 00 00&gt;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*我们可以通过数组下标的方式来单独修改某一位</span></span><br><span class="line"><span class="comment">*这时有同学就会问了，我输入的是72，为什么变成48了？</span></span><br><span class="line"><span class="comment">*因为我们输入的是十进制的72要转化为十六进制的数值</span></span><br><span class="line"><span class="comment">*而72转16进制为0000 0010 0000 1000 =&gt; 48</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">buffer4[<span class="number">0</span>] = <span class="number">72</span>;</span><br><span class="line">buffer4[<span class="number">4</span>] = <span class="number">0x66</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buffer4);<span class="comment">// &lt;Buffer 48 00 00 00 66 00 00 00&gt;</span></span><br></pre></td></tr></table></figure><p><strong>3）、Buffer与文件操作</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入文件模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取文本文件text.txt中的内容</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*当我们从一个文件中读取一个东西，本质上读取的都是一些二进制数据（重要）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&quot;./text.txt&quot;</span>,<span class="function">(<span class="params">err,data</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);<span class="comment">//&lt;Buffer e6 88 91 e4 b8 8e e6 88 91 e5 91 a8 e6 97 8b e4 b9 85 ef bc 8c e5 ae 81 e5 81 9a e6 88 91 ef bc 81&gt;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>()) <span class="comment">// 我与我周旋久，宁做我！</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取图片文件</span></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&quot;./东京复仇者.jpg&quot;</span>,<span class="function">(<span class="params">err,data</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);<span class="comment">// &lt;Buffer 52 49 46 46 cc 99 00 00 57 45 42 50 56 50 38 20 ... 39330 more bytes&gt;</span></span><br><span class="line">    fs.<span class="title function_">writeFile</span>(<span class="string">&quot;佐野万次郎.jpg&quot;</span>,data, <span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;图片写入成功！！！&quot;</span>); <span class="comment">// 图片写入成功！！！</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 我们的在频繁使用<strong>Buffer.alloc()</strong> 去创建Buffer时，这会非常消耗操作系统的性能。然而，Node为了提高性能，它对Buffer进行了一个封装。事实上，我们在创建Buffer是时，并不会频繁的向操作系统申请内存， 他会默认去申请一个<strong>8 * 1024</strong>字节大小的内存，也就是8kb。有同学会问你怎么知道的？这时我们就需要看一下Node的源码了,。<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce6a2078f8934868bd264ad01b70843e~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h3 id="4、Postman"><a href="#4、Postman" class="headerlink" title="4、Postman"></a>4、Postman</h3><p>&amp;emsp;在讲下面http模块以及后面的Express框架和Koa框架之前，我们先来学习以下接口测试工具<code>Postman</code>的基本使用。我们在平时的开发过程中，特别是要与接口打交道时，无论是写接口还是调用接口，我们一般都会去先测试一下。从分层测试来说，接口测试是性价比最高的<br/><br>（1）、什么是Postman? <br/><br>&amp;emsp;postman是一款功能强大的网页调试和模拟发送HTTP请求的Chrome插件，支持几乎所有类型的HTTP请求，操作简单且方便，如果我们需要在chrome中下载，则需要翻墙。而在这里我推荐大家下载postmen软件同样可以支持我们后面的学习。<br>Postman下载地址：<a href="https://www.postman.com/downloads/">https://www.postman.com/downloads/</a></p><h3 id="5、http模块"><a href="#5、http模块" class="headerlink" title="5、http模块"></a>5、http模块</h3><p>&amp;emsp;通过对于http模块的学习，我们可以更好的了解框架的底层原理。如果我们只知道框架，那么我们学习到的知识其实是很少的，因为框架它已经为我们已经封装好了很多的API，我们在实际的开发过程中可以选择使用框架，这样可以大大的减少我们开发的时间。<br/><br><strong>（1）、什么是web服务器？</strong> <br/><br>&amp;emsp;当应用程序（客户端）需要某个资源时，可以向一台服务器，同过HTTP请求获取到这个资源。提供资源的这个服务，就是个web服务器。<br/><br><strong>（2）、开源服务器</strong> <br/><br>&amp;emsp;以下是我们常用的一些Web服务器,在这里我就不详细的介绍了，我会在后面附上相关的文档，如果有同学感兴趣的可以了解一下，</p><ul><li><strong>Apache</strong>：<a href="https://juejin.cn/post/6844903629363609607">https://juejin.cn/post/6844903629363609607</a></li><li><strong>Nginx</strong>：<a href="https://www.cnblogs.com/muhy/p/10528543.html">https://www.cnblogs.com/muhy/p/10528543.html</a></li><li><strong>Apach Tomcat</strong>：<a href="https://www.linuxprobe.com/apache-tomcat-intro.html">https://www.linuxprobe.com/apache-tomcat-intro.html</a></li><li><strong>Node.js</strong></li></ul><p><strong>（3）、小试牛刀：Node.js服务器搭建</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、导入http模块</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"><span class="comment">/*2、创建web服务器</span></span><br><span class="line"><span class="comment">*我们通过http模块中为我们提供的creatServer方法，就可以创建一个服务器了。</span></span><br><span class="line"><span class="comment">*req:request请求对象，包含请求相关信息（后面详细分析）</span></span><br><span class="line"><span class="comment">*res:response响应对象，包含我们要发送给客户端的信息（后面详细分析）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req,res</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *这里调用end方法相当于为我们做了两件事</span></span><br><span class="line"><span class="comment">    *1、调用res.write(&quot;Hello Server&quot;)</span></span><br><span class="line"><span class="comment">    *2、调用res.end(callback);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    res.<span class="title function_">end</span>(<span class="string">&quot;Hello Server&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//3、监听服务器启动</span></span><br><span class="line"><span class="comment">//不要使用1024以下的端口号（系统使用的端口）</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8000</span>,<span class="string">&quot;127.0.0.1&quot;</span>,<span class="function">() =&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;服务已经启动~&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>&amp;emsp;通过上面的方法我们就已经成功的搭建了一个服务器，那么如我们如何启动呢？在我们终端中输入：<code>node 文件名</code>，此时打开我们浏览器,就可以收到服务器返回给我们的内容了。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df2a44cfca374ea3954d5c7847e4a04c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br/><br>&amp;emsp;敲黑板，记重点！通过上面的方式（<code>node 文件名</code>）来启动服务器，一旦我们的文件的内容发生任何改变，我们就需要重新的运行一次，不觉的很麻烦吗？有没有什么方式只输入一次命令，就可以时刻的监听我们文件内容发生的改变。有，我可以明确的告诉你。这时候我们只需要安装一个工具包<code>nodemon</code>即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//全局安装nodemon</span><br><span class="line">npm install -g nodemon</span><br><span class="line">//检查是否安装成功</span><br><span class="line">nodemon --version</span><br></pre></td></tr></table></figure><p>&amp;emsp;此后我们运行代码使用的就是<code>nodemon 文件名</code>，这时候就可以<code>实时的监控代码发生的改变</code>，不需要每次修改代码都重启服务器。这对于后面我们的学习很有帮助，建议同学们都可以安装一下呀！<br/><br><strong>（4）、Node.js创建服务器的几种方式</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入http模块</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"><span class="comment">//方式一：通过creatServer()创建web服务器</span></span><br><span class="line"><span class="keyword">const</span> server1 = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req,res</span>) =&gt;</span>&#123;</span><br><span class="line">    res.<span class="title function_">end</span>(<span class="string">&quot;server1&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server1.<span class="title function_">listen</span>(<span class="number">8000</span>,<span class="string">&quot;127.0.0.1&quot;</span>,<span class="function">() =&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;server1启动成功！！！&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二：创建服务器原生的方式，通过Server类</span></span><br><span class="line"><span class="comment">//源码：使用此方式和上面的创建方式（本质上底层也是调用的new Server()）是相同的。</span></span><br><span class="line"><span class="keyword">const</span> server2 = <span class="keyword">new</span> http.<span class="title class_">Server</span>(<span class="function">(<span class="params">req,res</span>) =&gt;</span>&#123;</span><br><span class="line">    res.<span class="title function_">end</span>(<span class="string">&quot;server2&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听方法(有坑，下面会讲)</span></span><br><span class="line"><span class="comment">//方式1：只传一个回调函数</span></span><br><span class="line">server2.<span class="title function_">listen</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;server2已启动！！！&quot;</span>);</span><br><span class="line">    <span class="comment">//获取随机生成的端口号</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(server2.<span class="title function_">address</span>().<span class="property">port</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//方式2：不传端口号</span></span><br><span class="line">server2.<span class="title function_">listen</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;server2已启动！！！&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(server2.<span class="title function_">address</span>().<span class="property">port</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//方式3：不传主机host</span></span><br><span class="line">server2.<span class="title function_">listen</span>(<span class="number">8000</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;server2已启动！！！&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//方式4：三个参数都传</span></span><br><span class="line">server2.<span class="title function_">listen</span>(<span class="number">8000</span>,<span class="string">&quot;0.0.0.0&quot;</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;server2已启动！！！&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>&amp;emsp;通过方式一创建Web服务器本质上是和方式二相同的，<code>creatServer()在底层也是通过new Server类来创建Web服务器的</code>。我们来看一下Node.js源码.我们在文件中导入http模块，本质上它都会去我们的<code>node_modules</code>下的<code>lib</code>文件夹下去找<code>http.js</code>这个文件<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/50328c2c92ac49b984cdd02de24b0f10~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br><strong>注意:</strong> <br/><br>&amp;emsp;重点来了,我们来分析一下监听方法<code>listen()</code>，Server通过listen()方法来开启服务器，并且在某个主机和端口上监听网络请求。相信大家也看到上面的几种监听方法使用的例子了，它有三个参数。</p><ul><li><p><strong>port（端口号）</strong>：<code>可传可不传</code>，如果我们<code>不传</code>的话它会<code>随机为我们生成一个端口号</code>，要知道我们访问服务器是必须要拿到它的端口号的，那么我们怎么知道它生成的端口号是多少呢？别急，我们只需要通过<code>“服务器名.address().port”</code>就可以拿到它随机生成的端口号。如果我们选择传端口号，只要记住尽量<code>不要传小于1024的端口号</code>。在我们开发项目的时不用传，一般会把它配到<code>环境变量</code>中。</p></li><li><p><strong>主机host</strong>：<code>可传可不传</code>，不知道同学们有没有注意到我传host的时候，特意传了两个不同的地址，一个是<code>&quot;127.0.0.1&quot;</code>,另一个是<code>&quot;0.0.0.0&quot;</code>当然我们也可以传<code>localhost</code>（本质上它就是一个<code>域名</code>，通常情况下它会被解析成<code>&quot;127.0.0.1&quot;</code>），那它们又有什么特点和区别呢？<code>&quot;127.0.0.1&quot;</code>:<code>回环地址</code>，<strong>主机自己发出去的包，被自己接收</strong>，比如:我们监听”127.0.0.1”时，在同一个网段下的主机中，通过ip地址是不能访问的。<code>0.0.0.0:监听Ipv4上的所有地址</code>，根据端口找到不同的应用程序，比如：我们监听<code>&quot;0.0.0.0&quot;</code>时，同一个网段下的主机中，通过ip地址是可以访问到的，一般情况下，我们不传地址就使用它默认的<code>&quot;0.0.0.0&quot;</code>。</p></li><li><p>**callback(回调函数)**：<code>可传可不传</code>，</p></li></ul><p><strong>（5）、request请求详解</strong> <br/><br>&amp;emsp;我们先分析一下一个请求的组成结构<br><br/><br><strong>（6）、response响应详解</strong><br/><br><code>&quot;0.0.0.0&quot;</code>：监听Ipv4上的所有地址，再根据端口找到不同的应用程序，比如我们监听0.0.0.0时，同一个网段下的主机中，通过ip地址是可以访问到的。一般情况下我们不传地址就使用它默认的0.0.0.0</p><h3 id="5、Express"><a href="#5、Express" class="headerlink" title="5、Express"></a>5、Express</h3><p>&amp;emsp;Express框架，</p><h3 id="6、Koa2"><a href="#6、Koa2" class="headerlink" title="6、Koa2"></a>6、Koa2</h3><p>&amp;emsp;前面我们已经学习了Express框架了，现在我们在来学习一个更加流行的框架Koa。<br/><br>Koa的官方介绍：Node.js的下一代框架。<br/><br>事实上，Koa是Express同一个团队开发的一个新的web框架；<br>目前团队的核心开发者TJ（这里值得说一下TJ对我们的前端做了很多的贡献，记得尤大曾经被问到有没有偶像的时候，尤大就说了TJ）的主要精力也在维护Koa，express已经交给团队去维护了；<br>Koa旨在为Web应用程序和API提供更小、更丰富和更强大的能力；<br>相对于express具有更强的异步处理能力（后续我们会进行对比）；<br>Koa的核心代码就只有1600+行，是一个更加轻量化的框架，我们可以根据需要进行安装和使用中间件。<br/><br><strong>（1）、Koa初体验</strong> <br/><br>要使用Koa之前我们第一步还是去下载这个库，<br>npm install koa</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入koa</span></span><br><span class="line"><span class="keyword">const</span> koa = <span class="built_in">require</span>(<span class="string">&quot;koa&quot;</span>);</span><br><span class="line"><span class="comment">//express导出的是函数，koa导出的是一个类</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title function_">koa</span>();</span><br><span class="line"><span class="comment">//context:上下文,ctx</span></span><br><span class="line"><span class="comment">//next：dispatch</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">ctx,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// console.log(&quot;中间件被执行&quot;);</span></span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//当你执行完所有的中间件之后，如果还没有返回结果，此时服务器不会像express框架一样</span></span><br><span class="line"><span class="comment">//会一直等待，而是直接返回一个Not Found</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">8000</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;koa初体验服务器启动成功~&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> koa = <span class="built_in">require</span>(<span class="string">&quot;koa&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title function_">koa</span>();</span><br><span class="line"><span class="comment">//没有提供下面的注册方式</span></span><br><span class="line"><span class="comment">//methods方式：app.get(),app.post() ,</span></span><br><span class="line"><span class="comment">//path方式：app.use(&quot;/home&quot;,(ctx,next) =&gt; &#123;&#125;)</span></span><br><span class="line"><span class="comment">/* 连续注册中间件</span></span><br><span class="line"><span class="comment">app.use((ctx,next) =&gt; &#123;</span></span><br><span class="line"><span class="comment">&#125;,(ctx,next) =&gt; &#123;</span></span><br><span class="line"><span class="comment">&#125;...)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//use注册中间件</span></span><br><span class="line"><span class="comment">//1、我们需要手动判断是否为get、post等请求</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">ctx,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(ctx.<span class="property">request</span>.<span class="property">url</span> === <span class="string">&quot;/login&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ctx.<span class="property">response</span>.<span class="property">method</span> === <span class="string">&quot;GET&quot;</span>) &#123;</span><br><span class="line">            ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">&quot;login sucess~&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">&quot;other request~&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">8000</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;koa初体验服务器启动成功~&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>路由的使用<br>koa官方并没有为我们提供路由的库，我们可以选择第三方的库：koa-router<br>npm install koa-router<br>yarn add koa-router<br>我们可以先封装一个user.route.js的文件<br>在app中将router.routers()注册为中间件<br>注意：<br>allwedMethods用于判断某一个method是否支持：<br>如果我们请求get，那么是正常的请求，因为我们实现了get<br>如果我们请求put、delete、patch，那么自动报错：Method Not Allowed 状态码：405<br>如果我们请求link、copy、lock、，那么就自动报错，：Not Implemented 状态码501;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const Router = require(&quot;koa-router&quot;);</span><br><span class="line"></span><br><span class="line">const router = new Router(&#123;prefix: &quot;/users&quot;&#125;);</span><br><span class="line"></span><br><span class="line">router.get(&quot;/&quot;,(ctx,next) =&gt; &#123;</span><br><span class="line">    ctx.response.body = &quot;put request~&quot;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.put(&quot;/&quot;,(ctx,next) =&gt; &#123;</span><br><span class="line">    ctx.response.body = &quot;users request~&quot;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">module.exports = router;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const koa = require(&quot;koa&quot;);</span><br><span class="line"></span><br><span class="line">const userRouter = require(&quot;./router/user&quot;);</span><br><span class="line"></span><br><span class="line">const app = new koa();</span><br><span class="line"></span><br><span class="line">// app.use((ctx,next) =&gt; &#123;</span><br><span class="line">//     ctx.response.body = &quot;Hello World&quot;</span><br><span class="line">// &#125;)</span><br><span class="line">\</span><br><span class="line"></span><br><span class="line">app.use(userRouter.routes())</span><br><span class="line">//返回错误请求结果</span><br><span class="line">app.use(userRouter.allowedMethods())</span><br><span class="line"></span><br><span class="line">app.listen(8000,() =&gt; &#123;</span><br><span class="line">    console.log(&quot;koa初体验服务器启动成功~&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> koa = <span class="built_in">require</span>(<span class="string">&quot;koa&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Router</span> = <span class="built_in">require</span>(<span class="string">&quot;koa-router&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title function_">koa</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userRouter = <span class="keyword">new</span> <span class="title class_">Router</span>(&#123;<span class="attr">prefix</span>:<span class="string">&quot;/users&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">userRouter.<span class="title function_">get</span>(<span class="string">&quot;/:id&quot;</span>,<span class="function">(<span class="params">ctx,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//http://localhost:8000/users/abc?usrename=xiongwen&amp;password=123456</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(ctx.<span class="property">request</span>.<span class="property">params</span>); <span class="comment">//&#123; id: &#x27;abc&#x27; &#125; </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(ctx.<span class="property">request</span>.<span class="property">query</span>);<span class="comment">//[Object: null prototype] &#123; usrename: &#x27;xiongwen&#x27;, password: &#x27;123456&#x27; &#125;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(userRouter.<span class="title function_">routes</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.use((ctx,next) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//     console.log(ctx.request.url); ///login?usrename=xiongwen&amp;password=123456</span></span><br><span class="line"><span class="comment">//     console.log(ctx.request.query);//[Object: null prototype] &#123; usrename: &#x27;xiongwen&#x27;, password: &#x27;123456&#x27; &#125; </span></span><br><span class="line"><span class="comment">//     console.log(ctx.request.params);</span></span><br><span class="line"><span class="comment">//     ctx.response.body = &quot;Hello World&quot;</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">8000</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;koa初体验服务器启动成功~&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> koa = <span class="built_in">require</span>(<span class="string">&quot;koa&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bodyparser = <span class="built_in">require</span>(<span class="string">&quot;koa-bodyparser&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> multer = <span class="built_in">require</span>(<span class="string">&quot;koa-multer&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title function_">koa</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> upload = <span class="title function_">multer</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//安装第三方库解析json数据 koa-bodyparser</span></span><br><span class="line"><span class="comment">//他可以解析json和urlencoded,但是不能解析form-data</span></span><br><span class="line"><span class="comment">//如果想要解析form-data形式的参数，需要安装一个库</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">bodyparser</span>());</span><br><span class="line"><span class="comment">//不建议这么使用</span></span><br><span class="line">app.<span class="title function_">use</span>(upload.<span class="title function_">any</span>())</span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">ctx,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(ctx.<span class="property">request</span>.<span class="property">body</span>); <span class="comment">// &#123; title: &#x27;huawei&#x27;, price: 4999 &#125;</span></span><br><span class="line">    ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">8000</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;服务器启动成功~&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Koa和Express源码对比:<br>学习玩两个框架之后，我们可以发现koa和express之间的区别<br>从架构设计上来说:<br>express是完整和强大的，其中帮助了我们内置了非常多好用的功能<br>koa是简洁自由的，它只包含最核心的功能，并不会对我们使用其他中间件进行任何的限制<br>    甚至是在app中连基本的get、post都没有给我们提供<br>    我们需要通过自己或者路由来判断请求方式或者其他功能<br>因为express和koa框架它们的核心其实都是中间件<br>    但是他们的中间件事实上，他们的中间件执行机制是不同的，特别是针对某个中间件包含的某个异步操作时<br>    所以，接下来，我们再来研究express和koa中间件的执行顺序问题；</p><p>koa对比express<br>我们通过一个需求来演示所有的过程<br>    假如有三个中间件会在一次请求中匹配到，并且按照顺序执行<br>    我们希望最终实现的方案是<br>        在middleware1中，在req.message中添加一个字符串aaa<br>        在middleware2中，在req.messgae中添加一个字符串bbb<br>        在middleware3中，在req.message中添加一个字符串ccc<br>        当所有内容添加结束后，在middleware1中，通过res返回最终的结果；</p><p>Koa的洋葱模型 <br/><br>两层理解含义 <br/><br>    中间件处理代码的过程 <br/><br>    Response返回body执行 <br/><br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2aa211fc3d54de3b82d675261885fde~tplv-k3u1fbpfcp-watermark.image" alt="洋葱模型"></p>]]></content>
      
      
      
        <tags>
            
            <tag> NodeJS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
